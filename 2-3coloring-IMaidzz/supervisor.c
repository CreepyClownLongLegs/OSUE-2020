/**
 * @file supervisor.c
 * @author [Dein ? Vorname] [Dein ? Nachname] <matrikelnummer@student.tuwien.ac.at>
 * @date 11.12.2023
 *
 * @brief Supervisor program
 * 
 * @details Continuously recieves solutions to the 3 coloring of a graph 
 * by the generator program(s) and prints the best solutions so far or that
 * the graph is 3 colorable
 **/

#include <ctype.h>
#include <getopt.h>
#include <stdbool.h>
#include <errno.h>
#include <fcntl.h>
#include <semaphore.h>
#include <stdio.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <unistd.h>
#include <time.h>
#include <stdlib.h>
#include <inttypes.h>
#include <string.h>
#include <time.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/time.h>
#include <unistd.h>

#include "common.h"

/**
 * @brief variable name of program
 * used to inform the used of which program is currently executing which process
 */
char *prog_name;

/**
 * @brief indicator whather or not the program should terminate
*/
volatile sig_atomic_t quit = 0;

/**
 * @brief the function changes the variable quit to true
 * @details this function is usualy called after it recieves a signal
 * @param signal it is the signal the program recieves externaly
*/
void handle_signal(int signal) { quit = 1; }

/**
 * @brief function exits program when error occurs
 * @details exits program with status of EXIT_FAILURE and prints to user what went wrong
 * @param msg is the msg that the user will rexieve of what part of the program exactly expirienced an error
 */
static void error_eit(char *msg) {
    fprintf(stderr, "%s : %s", prog_name, msg);
    exit(EXIT_FAILURE);
}

/**
 * @brief function returns correct usage of the program
 * @details functions prints on stdout the USAGE and examples of the program
*/
static void usage(void){
    printf("USAGE: supervisor [-n limit] [-w delay]\n");
    printf("the n argument takes a number as a paramether that signifies how many solutions can be generated by the generator(s) before the program terminates");
    printf("the w argument takes in the waiting time before a solution should be printes");
}

/**
 * @brief opens all resources for progam to work
 * @details only works if supervisor was previously called, 
 * opens shared memory as a circular buffer,semaphores
 * @param buffer is the circular buffer that needs to be initialised in this function, the shared memory
 * @param shmfd is the link to the memory location of the shared memory
*/
static void opening_resources(struct cirula_buffer **buffer, int *shmfd) {

    *shmfd = shm_open(SHM_NAME, O_RDWR | O_CREAT, 0600);

    if (*shmfd == -1) {
        error_eit("Program failed to open shared memory");
    }

    if (ftruncate(*shmfd, sizeof(struct cirula_buffer)) < -1) {
        error_eit("Program failed to size memory");
    }

    *buffer = mmap(NULL, sizeof(struct cirula_buffer), PROT_READ | PROT_WRITE, MAP_SHARED, *shmfd, 0);

    if (*buffer == MAP_FAILED) {
        error_eit("Program failed while mapping memory");
    }

    if (close(*shmfd) < -1) {
        error_eit("Program failed to close shared memory link");
    }

    sem_unlink(SEM_READ);
    sem_unlink(SEM_WRITE);
    sem_unlink(SEM_MUTEX);

sem_read = sem_open(SEM_READ, O_CREAT | O_EXCL, 0600,0);
if (sem_read == SEM_FAILED) {
    error_eit("Failed opening the semaphore read");
}

//initialised with maxx num cus it has all the buffer places open for writing at initialisation
sem_write = sem_open(SEM_WRITE,O_CREAT | O_EXCL, 0600, MAX_NUM);
if (sem_write == SEM_FAILED) {
    error_eit("Failed opening the semaphore write");
}

sem_mutex = sem_open(SEM_MUTEX,O_CREAT | O_EXCL, 0600, 1);
if (sem_mutex == SEM_FAILED) {
    error_eit("Failed opening the semaphore mutex");
}

}


/**
 * @brief cleans up all resources opened with 'opening resources' function
 * @details closes shared memory ,semaphores and inrements the sem_mutes as to 
 * make all remaining generators terminate in case one is still hanging in the queue
 * @param buffer is the shared memory buffer
*/
static void clean_up(struct cirula_buffer * buffer){

    //post semaphores to avoid deadlock

    sem_post(sem_mutex);

    //to ensure that all processes end
    buffer->terminate = 1;
    quit = 1;

    if (munmap(buffer ,sizeof(*buffer)) == -1)
{

    error_eit("Program failed unmapping memory");
}

if (shm_unlink(SHM_NAME) < -1)
{
    error_eit("Program failed unlinking of shared memory");
}

    //incrementing semaphores so that a deadlock doesnt occur

    if(sem_close(sem_read) < -1){
        error_eit("Failed closing the read semaphore");
    }

    if (sem_unlink(SEM_READ) < -1)
    {
        error_eit("Failed unlinking the read semaphore");
    }
    
    if(sem_close(sem_write) < -1){
        error_eit("Failed unliking the read semaphore");
    }

    if (sem_unlink(SEM_WRITE) < -1)
    {
        error_eit("Failed unlinking the read semaphore");
    }

    if(sem_close(sem_mutex) < -1){
        error_eit("Failed unliking the read semaphore");
    }

    if (sem_unlink(SEM_MUTEX) < -1)
    {
        error_eit("Failed unlinking the read semaphore");
    }


}


/**
 * @brief reads  from buffer
 * @details reads from the buffer and increments the reading index every time and 
 * returns the result as an edge_list 
 * @param buffer is the circular buffer
 * @param read_pos is the position at which the buffer should read
 * @return edge_list that was read at given position in the buffer
*/
static edge_list read_buffer_at_position(struct cirula_buffer *buffer, int read_pos) {

    // Ensure read_pos is within a valid range
    if (read_pos < 0 || read_pos >= MAX_NUM) {
        // Handle invalid read position
        fprintf(stderr, "Invalid read position: %d\n", read_pos);
        exit(EXIT_FAILURE);
    }

    // Copy the content of the circular buffer at the specified position to a new edge_list
    edge_list toreturn;
    memcpy(&toreturn, &buffer->lists[read_pos], sizeof(edge_list));
    buffer->read_index = (buffer->read_index +1) % MAX_NUM; 

    sem_post(sem_write);

    return toreturn;
}


int main(int argc, char ** argv){
    prog_name = argv[0];

struct cirula_buffer * buffer = NULL;

int limit = 0;
int delay = 0;

bool graphis3colorable = false;
int shmfd = 0;

//getting arguments from the line

int chara;

while ((chara = getopt(argc, argv, "n:w:")) != -1)
{
    switch (chara)
    {
    case 'n':
        if (optarg == NULL)
        {
            usage();
            error_eit("no argument was given for option -w");
        }
        limit = strtol(optarg, NULL, 10);
        break;
    case 'w':
        if (optarg == NULL)
        {
            usage();
            error_eit("no argument was given for option -w");
        }
        delay = strtol(optarg, NULL, 10);
        break;
    case '?':
        //still add usage
        usage();
        error_eit("Wrong option argument given");
        break;
    default:
        break;
    }
}

// opening shared memory
opening_resources(&buffer, &shmfd);

buffer->read_index = 0;
buffer->write_index = 0;
buffer->terminate = 0;
buffer->total_num_of_edges = MAX_NUM;

(*buffer).limit = 0;
edge_list list;
list.num_of_vertices = 0;

//setup signal 

struct sigaction sa;
memset(&sa, 0, sizeof(sa));
sa.sa_handler = handle_signal;
sigaction(SIGINT, &sa, NULL);
sigaction(SIGTERM, &sa, NULL);

//read from memory
while (!quit)
{
    if (sem_wait(sem_read) == -1)
        {
            //ccheck if interupted by a signal
            if (errno == EINTR)
            {
                continue;
            }

        error_eit("Fail while decrementing sem_read");
    }

    list = read_buffer_at_position(buffer, buffer->read_index);

    if (buffer->limit > limit-1 && limit != 0)
    {
        (*buffer).terminate = 1;
        quit = 1;
        break;
    }

    if (list.num_of_vertices == 0)
    {
        graphis3colorable = true;
        (*buffer).terminate = 1;
        quit = 1;
        break;

    }else{
    
    if (list.num_of_vertices < buffer->total_num_of_edges)
    {
        /**
        sleep(delay);
        printf("Solution with %i vertices : ", list.num_of_vertices);
        for (size_t i = 0; i < list.num_of_vertices; i++)
        {

            printf("Edge from %i to %i\n", list.edges[i].from.number, list.edges[i].to.number);
        }
        */
        (*buffer).total_num_of_edges = list.num_of_vertices;
    }
    }
    

    if (buffer->terminate == 1) {
        break;
    }

}

int lowest_num_of_edges = buffer->total_num_of_edges;

//clean up of resources 

clean_up(buffer);

//only calling sleep after all resources were closed
sleep(delay);
if (!graphis3colorable)
{
    printf("The graph might not be 3-colorable, best solution removes %i edges.\n", lowest_num_of_edges);
}
else{
    printf("The graph is 3-colorable!\n");
}
fflush(stdout);

exit(EXIT_SUCCESS);

}
